package mines;

import java.util.HashSet;
import java.util.Set;

public class Mines {
	
	private Place [][] matMines;
	private int numOfMines;
	private int height, width;
	private boolean showAll;
	public Mines(int height, int width, int numMines)
	{
		matMines = new Place [height][width];
		for(int index = 0; index < height; index++)
		{
			for(int jIndex = 0; jIndex < width; jIndex++)
			{
				matMines[index][jIndex] = new Place(index, jIndex);
			}
		}
		this.height = height;
		this.width = width;
		showAll = false;
		numOfMines = numMines;
	}
	
	public boolean addMine(int i, int j)
	{
		if (matMines[i][j].mine == 0) //the place is not a mine
		{
			matMines[i][j].mine = 1;//puts the mine is this location
			Set<Place> curNeighbor = matMines[i][j].addNeighbor(i,j);
			for(Place elem :curNeighbor)
			{
				if(elem.getMine() == 0)
					elem.minesNum++;
			}
			return true;
		}
		return false; //the place wasn't empty
	}
	
	public class Place 
	{
		private int i,j;
		private boolean open; //checks if the place is open
		private int flag; //checks if it's a flag
		private int mine;//checks if it's a mine
		private int minesNum; //checks if it's mine
		
		
		public Place (int i, int j)
		{
			open = false;
			flag = 0;
			mine = 0;
			this.i = i;
			this.j = j;
			minesNum = 0;
				
		}
		/*the method adds all the neighbor*/
		public Set<Place> addNeighbor(int i, int j)
		{
			Set<Place> neighbor = new HashSet<Place>(); //saves all the vertices
			if(i+1 < height)
			{
				neighbor.add(matMines[i+1][j]);
			}
			if(i-1 >= 0)
			{
				neighbor.add(matMines[i-1][j]);
			}
			if(j+1 < width)
			{
				neighbor.add(matMines[i][j+1]);
			}
			if(j-1 >= 0)
			{
				neighbor.add(matMines[i][j-1]);
			}
			if(i+1 < height && j+1 < width)
			{
				neighbor.add(matMines[i+1][j+1]);
			}
			if(i-1 >= 0 && j-1 >= 0)
			{
				neighbor.add(matMines[i-1][j-1]);
			}
			if(i-1 >= 0 && j+1 < width)
			{
				neighbor.add(matMines[i-1][j+1]);
			}
			if(i+1 < height && j-1 >= 0)
			{
				neighbor.add(matMines[i+1][j-1]);
			}
			return neighbor;
		}
		public boolean isOpen() {
			return open;
		}

		public int getMine() {
			return mine;
		}
		
		public int getFlag() {
			return flag;
		}

		public int getMinesNum() {
			return minesNum;
		}
	}
		
	public boolean open(int i, int j)
	{
		if(matMines[i][j].getMine() == 1)
		{
			return false;
		}
		matMines[i][j].open = true;	
		if (matMines[i][j].getMinesNum() == 0)
			openAll(i,j);
		return true;
	}
	
	public void openAll(int i, int j)
	{
		if(matMines[i][j].getMine() == 1 || matMines[i][j].getMinesNum() > 0) 
			return;
		Set<Place> temp = matMines[i][j].addNeighbor(i,j);
		for(Place elem:temp)
		{
			if(elem.getFlag() == 0 && elem.isOpen() == false && elem.getMine() == 0)
			{
				elem.open = true;
			/*open recursively the neighbors that aren't flags and mines*/
				openAll(elem.i, elem.j);
			}
		
		}
	}
	
	
	public void toggleFlag(int x, int y) 
	{
		if(matMines[x][y].getFlag() == 1)
			matMines[x][y].flag = 0;
		else matMines[x][y].flag = 1;
	}
	
	public boolean isDone()
	{
		for(int i = 0; i < height; i++)
		{
			for(int j = 0; j < width; j++)
			{
				/*if the current place isn't a mine and it's close - return false*/
				if(matMines[i][j].getMine() == 0 && matMines[i][j].isOpen() == false)
				{
					return false;
				}	
			}
		}
		/*All non-mine places are open*/
		return true;
	}
	
	public String get(int i, int j) 
	{
		if(showAll == true)
		{
			if(matMines[i][j].getFlag() == 1) return "F";
			if (matMines[i][j].getMine() == 1 ) return "X";
			if(matMines[i][j].getMinesNum() > 0) return String.valueOf(matMines[i][j].getMinesNum());
			return " ";
		}
		else
		{
			if(matMines[i][j].isOpen() == false )//the place is close
			{
				if(matMines[i][j].getFlag() == 1) //+ the place is a flag
				{
					return "F";
				}
				return ".";// + the place isn't a flag
			}
			/*the place is open*/
			if (matMines[i][j].getMine() == 1 )// checks if it's a mine
			{
				return "X";
			}
				
			/*the place is open but not a mine*/
			if(matMines[i][j].getMinesNum() > 0)//+ the place surrounded by mines
			{
				return String.valueOf(matMines[i][j].getMinesNum());
			}
			
			return " "; //+ the place isn't surrounded by mines
		}
	}
	
	public void setShowAll(boolean showAll) 
	{
		this.showAll = showAll;
	}
	
	public String toString() 
	{
		StringBuilder str = new StringBuilder("");
		for(int i = 0; i < height; i++)
		{
			for(int j = 0; j < width; j++)
			{
				str.append(get(i,j));
			}
			str.append("\n");//end of line			
		}
		return str.toString();
	}

}
